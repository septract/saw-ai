/*
 * FEAL-8 SAW Verification - 1989 Implementation (LP64-Patched)
 *
 * This is the PRIMARY verification target.
 *
 * Challenge features of the 1989 implementation:
 *   - Union-based byte manipulation (endian-dependent)
 *   - Global state for expanded key (K[16], K89, K1011, K1213, K1415)
 *   - Lazy-initialized lookup table for Rot2
 *
 * C source: feal8_1989_portable.c (LP64-patched version of Schneier archive code)
 * Cryptol spec: feal8.cry (HAC reference), feal8_1989.cry (little-endian variant)
 */

// Load Cryptol specifications
import "feal8.cry";       // HAC-based spec (S0, S1, ROT2, etc.)
import "feal8_1989.cry";  // 1989-specific little-endian functions (FK_1989, f_1989, etc.)

// Load LLVM bitcode (1989 implementation)
m <- llvm_load_module "feal8_1989.bc";

print "=== FEAL-8 1989 Implementation Verification ===";
print "";
print "Challenge: unions, globals, lazy-init lookup table";
print "";

// ============================================================================
// Preliminary: Verify Rot2 lookup table initialization formula
//
// The 1989 C code builds a 256-entry lookup table using a loop that computes:
//   RetVal[i] = (4*i mod 256) + (i / 64)
//
// We prove this formula equals ROT2(i) = i <<< 2, justifying our assumption
// that the initialized table equals rot2Table.
// ============================================================================

print "Proving Rot2 initialization formula correct...";
prove_print z3 {{ \x -> rot2_loop_formula x == ROT2 x }};
print "  rot2_loop_formula == ROT2: PROVED";
print "";

// ============================================================================
// Stage 1: Verify Rot2 function
//
// The 1989 implementation uses a lazy-initialized 256-entry lookup table.
// On first call, it builds the table; subsequent calls use the table.
//
// C: ByteType Rot2(ByteType X)
// Cryptol: ROT2 : Byte -> Byte
// ============================================================================

print "=== Stage 1: Rot2 (2-bit rotation with lookup table) ===";
print "";

// The 1989 Rot2 uses a lazy-initialized lookup table:
//   static int First = 1;
//   static ByteType RetVal[256];
//
// Strategy: Verify steady-state behavior with table already initialized.
// We set First=0 and RetVal to the correct precomputed values.

// Cryptol helper: compute the Rot2 lookup table
let {{
  // The lookup table: RetVal[i] = ROT2 i for all i in 0..255
  rot2Table : [256][8]
  rot2Table = [ ROT2 i | i <- [0..255] ]
}};

// Rot2 specification (steady-state: table already initialized)
let Rot2_spec : CrucibleSetup () = do {
    // Set up static variable "First" = 0 (table already initialized)
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});

    // Set up static array "RetVal" with precomputed values
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Input: single byte
    x <- llvm_fresh_var "x" (llvm_int 8);

    // Execute Rot2(x)
    llvm_execute_func [llvm_term x];

    // Post-state: globals unchanged (table is read-only in steady state)
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Output should match Cryptol ROT2
    llvm_return (llvm_term {{ ROT2 x }});
};

print "Verifying Rot2 (steady-state, table initialized)...";
Rot2_ov <- llvm_verify m "Rot2" [] false Rot2_spec z3;
print "  Rot2 (steady-state): VERIFIED";

// Rot2 specification (first-call: table needs initialization)
// This verifies the C loop correctly builds rot2Table
let Rot2_init_spec : CrucibleSetup () = do {
    // Pre-state: First = 1 (table not yet initialized)
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 1 : [32] }});

    // Pre-state: RetVal is uninitialized (fresh symbolic)
    llvm_alloc_global "Rot2.RetVal";

    // Input: single byte
    x <- llvm_fresh_var "x" (llvm_int 8);

    llvm_execute_func [llvm_term x];

    // Post-state: First = 0 (initialization complete)
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});

    // Post-state: RetVal is correctly initialized to rot2Table
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Output should match Cryptol ROT2
    llvm_return (llvm_term {{ ROT2 x }});
};

print "Verifying Rot2 (first-call, table initialization)...";
llvm_verify m "Rot2" [] false Rot2_init_spec z3;
print "  Rot2 (first-call): VERIFIED";
print "";

// ============================================================================
// Stage 2: Verify S0 and S1 functions
//
// C: ByteType S0(ByteType X1, ByteType X2)
//    ByteType S1(ByteType X1, ByteType X2)
// Cryptol: S0, S1 : Byte -> Byte -> Byte
// ============================================================================

print "=== Stage 2: S0/S1 (S-box functions) ===";
print "";

// S0 and S1 are simple wrappers around Rot2.
// For compositional verification, we verify them with globals setup,
// then use them as overrides for f.

// S0 specification with globals
let S0_spec : CrucibleSetup () = do {
    // Set up Rot2's static state
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Inputs: two bytes
    x1 <- llvm_fresh_var "x1" (llvm_int 8);
    x2 <- llvm_fresh_var "x2" (llvm_int 8);

    llvm_execute_func [llvm_term x1, llvm_term x2];

    // Output matches Cryptol S0
    llvm_return (llvm_term {{ S0 x1 x2 }});
};

// S1 specification with globals
let S1_spec : CrucibleSetup () = do {
    // Set up Rot2's static state
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Inputs: two bytes
    x1 <- llvm_fresh_var "x1" (llvm_int 8);
    x2 <- llvm_fresh_var "x2" (llvm_int 8);

    llvm_execute_func [llvm_term x1, llvm_term x2];

    // Output matches Cryptol S1
    llvm_return (llvm_term {{ S1 x1 x2 }});
};

print "Verifying S0 (with Rot2 override)...";
S0_ov <- llvm_verify m "S0" [Rot2_ov] false S0_spec z3;
print "  S0: VERIFIED";

print "Verifying S1 (with Rot2 override)...";
S1_ov <- llvm_verify m "S1" [Rot2_ov] false S1_spec z3;
print "  S1: VERIFIED";
print "";

// ============================================================================
// Stage 3: Verify f function (round function)
//
// C: HalfWord f(HalfWord AA, QuarterWord BB)
// Uses union-based byte extraction (endian-dependent!)
//
// Cryptol: f : Half -> SubKey -> Half
// ============================================================================

print "=== Stage 3: f (round function with unions) ===";
print "";

// BUG FOUND: The 1989 code is NOT 64-bit safe!
//
// The union { unsigned long All; ByteType Byte[4]; } assumes unsigned long
// is 32 bits (as it was in 1989). On modern 64-bit systems:
//   - unsigned long is 8 bytes (64 bits)
//   - ByteType Byte[4] is 4 bytes (32 bits)
//
// The code sets Byte[0-3] then reads All, which reads 4 uninitialized bytes.
// This is UNDEFINED BEHAVIOR on 64-bit systems.
//
// SAW correctly detects this: "Error during memory load" when returning
// RetVal.All after only initializing 4 of its 8 bytes.
//
// Workaround: Use llvm_fresh_var for return and llvm_postcond for low 32 bits.

// The 1989 f function uses union-based byte extraction.
// On little-endian (macOS ARM):
//   union { unsigned long All; ByteType Byte[4]; }
//   Byte[0] = bits 0-7 (LSB), Byte[3] = bits 24-31 (MSB)
//
// Types: HalfWord = unsigned long (64-bit), QuarterWord = unsigned int (32-bit)
// Bug: union only sets low 32 bits, but returns full 64 bits.

// f_1989 is imported from feal8_1989.cry

// f specification with globals (needed for S0/S1 overrides to match)
// NOTE: The C code was modified with portability fixes (zero-initialized unions).
// Original 1989 code had undefined high 32 bits on LP64 systems.
let f_spec : CrucibleSetup () = do {
    // Set up Rot2's static state
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Input: HalfWord (64-bit) and QuarterWord (32-bit)
    aa <- llvm_fresh_var "aa" (llvm_int 64);
    bb <- llvm_fresh_var "bb" (llvm_int 32);

    llvm_execute_func [llvm_term aa, llvm_term bb];

    // Post-state: globals unchanged
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Return value: full 64-bit match (portability fix ensures high bits are zero)
    llvm_return (llvm_term {{ f_1989 aa bb }});
};

// Note: Using Rot2_ov directly instead of S0_ov/S1_ov
// S0/S1 overrides have different global allocation, causing matching issues.
// Direct symbolic execution through S0/S1 with Rot2 override works.

print "Verifying f (with Rot2 override, symbolic S0/S1)...";
f_ov <- llvm_verify m "f" [Rot2_ov] false f_spec (w4_unint_z3 []);
print "  f: VERIFIED";
print "";

// ============================================================================
// Stage 4: Verify FK function (key schedule round)
//
// C: HalfWord FK(HalfWord AA, HalfWord BB)
// Similar union-based structure to f
//
// Cryptol: fK : Half -> Half -> Half
// ============================================================================

print "=== Stage 4: FK (key schedule round) ===";
print "";

// FK has the same union structure as f.
// FK(AA, BB): both inputs are HalfWord (64-bit), returns HalfWord

let FK_spec : CrucibleSetup () = do {
    // Set up Rot2's static state
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Input: two HalfWords (64-bit each)
    aa <- llvm_fresh_var "aa" (llvm_int 64);
    bb <- llvm_fresh_var "bb" (llvm_int 64);

    llvm_execute_func [llvm_term aa, llvm_term bb];

    // Post-state: globals unchanged
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Return value: full 64-bit match (portability fix ensures high bits are zero)
    llvm_return (llvm_term {{ FK_1989 aa bb }});
};

print "Verifying FK (with Rot2 override)...";
FK_ov <- llvm_verify m "FK" [Rot2_ov] false FK_spec (w4_unint_z3 []);
print "  FK: VERIFIED";
print "";

// ============================================================================
// Stage 5: Verify SetKey (key schedule)
//
// C: void SetKey(ByteType *KP)
// Writes to global state: K[16], K89, K1011, K1213, K1415
//
// Cryptol: keySchedule : Key -> SubKeys
//
// Strategy: Compositional verification using FK_ov override.
// The 1989 code passes FK arguments by value (HalfWord = 64-bit integer),
// so the FK override should match. This makes verification fast.
// ============================================================================

print "=== Stage 5: SetKey (key schedule with globals) ===";
print "";

// keySchedule_1989, computeWhiteningKeys, FK_1989 imported from feal8_1989.cry at top

// SetKey specification
let SetKey_spec : CrucibleSetup () = do {
    // Set up Rot2's static state (needed for FK's S0/S1 calls)
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Input: 8-byte key
    kp <- llvm_alloc_readonly (llvm_array 8 (llvm_int 8));
    key_bytes <- llvm_fresh_var "key_bytes" (llvm_array 8 (llvm_int 8));
    llvm_points_to kp (llvm_term key_bytes);

    // Output globals (allocate before execution)
    llvm_alloc_global "K";
    llvm_alloc_global "K89";
    llvm_alloc_global "K1011";
    llvm_alloc_global "K1213";
    llvm_alloc_global "K1415";

    llvm_execute_func [kp];

    // Compute expected key schedule
    // keySchedule_1989 returns [16][16], need to zext to [16][32] for C's unsigned int
    // computeWhiteningKeys returns [32], need to zext to [64] for C's unsigned long
    let expected_ks = {{ keySchedule_1989 key_bytes }};
    let wk = {{ computeWhiteningKeys expected_ks }};

    // K[16]: Each is unsigned int (32-bit), portability fix ensures high 16 bits are zero
    let c_k_arr = {{ [ zext k : [32] | k <- expected_ks ] }};
    llvm_points_to (llvm_global "K") (llvm_term c_k_arr);

    // Whitening keys: 64-bit HalfWords, portability fix ensures high 32 bits are zero
    llvm_points_to (llvm_global "K89") (llvm_term {{ zext wk.0 : [64] }});
    llvm_points_to (llvm_global "K1011") (llvm_term {{ zext wk.1 : [64] }});
    llvm_points_to (llvm_global "K1213") (llvm_term {{ zext wk.2 : [64] }});
    llvm_points_to (llvm_global "K1415") (llvm_term {{ zext wk.3 : [64] }});
};

print "Verifying SetKey (compositional with FK override)...";

// Keep FK_1989 uninterpreted so the solver just verifies structure matches
// without reasoning through FK internals.
SetKey_ov <- llvm_verify m "SetKey" [Rot2_ov, FK_ov] false SetKey_spec
    (w4_unint_z3 ["FK_1989", "S0", "S1"]);
print "  SetKey: VERIFIED";
print "";

// ============================================================================
// Stage 6: Verify Encrypt/Decrypt
//
// C: void Encrypt(ByteType *Plain, ByteType *Cipher)
//    void Decrypt(ByteType *Cipher, ByteType *Plain)
// Uses global key state set by SetKey
//
// Strategy: Set concrete key state (from test key), verify with symbolic plaintext.
// Uses f_ov override for the round function.
// ============================================================================

print "=== Stage 6: Encrypt/Decrypt ===";
print "";

// Test key for concrete key schedule
// NOTE: Using concrete key while debugging compositional verification.
// Goal is fully symbolic key verification once this works.
let test_key_bytes = {{ [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef] : [8][8] }};
let test_subkeys_16 = {{ keySchedule_1989 test_key_bytes }};
let test_wk_32 = {{ computeWhiteningKeys test_subkeys_16 }};

// Convert to C types - these are what SAW sees in the globals
// K[16]: unsigned int (32-bit), stores 16-bit subkeys zero-extended
let c_subkeys = {{ [ zext k : [32] | k <- test_subkeys_16 ] }};
// Whitening keys: unsigned long (64-bit), stores 32-bit values zero-extended
let c_k89 = {{ zext test_wk_32.0 : [64] }};
let c_k1011 = {{ zext test_wk_32.1 : [64] }};
let c_k1213 = {{ zext test_wk_32.2 : [64] }};
let c_k1415 = {{ zext test_wk_32.3 : [64] }};

// Encrypt specification
let Encrypt_spec : CrucibleSetup () = do {
    // Set up Rot2's static state (needed for f calls)
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Set up key state globals with concrete test key
    llvm_alloc_global "K";
    llvm_points_to (llvm_global "K") (llvm_term c_subkeys);
    llvm_alloc_global "K89";
    llvm_points_to (llvm_global "K89") (llvm_term c_k89);
    llvm_alloc_global "K1011";
    llvm_points_to (llvm_global "K1011") (llvm_term c_k1011);
    llvm_alloc_global "K1213";
    llvm_points_to (llvm_global "K1213") (llvm_term c_k1213);
    llvm_alloc_global "K1415";
    llvm_points_to (llvm_global "K1415") (llvm_term c_k1415);

    // Input: symbolic 8-byte plaintext
    plain_ptr <- llvm_alloc_readonly (llvm_array 8 (llvm_int 8));
    plain_bytes <- llvm_fresh_var "plain_bytes" (llvm_array 8 (llvm_int 8));
    llvm_points_to plain_ptr (llvm_term plain_bytes);

    // Output: 8-byte ciphertext buffer
    cipher_ptr <- llvm_alloc (llvm_array 8 (llvm_int 8));

    llvm_execute_func [plain_ptr, cipher_ptr];

    // Post-state: globals unchanged
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Expected ciphertext from Cryptol (using C-typed subkeys/whitening keys)
    let expected_cipher = {{ encrypt_1989 plain_bytes c_subkeys (c_k89, c_k1011, c_k1213, c_k1415) }};
    llvm_points_to cipher_ptr (llvm_term expected_cipher);
};

// Prove the encrypt unroll lemma (Cryptol-only, no C code involved)
// This shows encrypt_1989 == encrypt_1989_unrolled with f_1989 uninterpreted
print "Proving encrypt unroll lemma...";
encrypt_unroll <- prove_print
    (w4_unint_z3 ["f_1989", "S0", "S1"])
    {{ \plain ks wk -> encrypt_1989 plain ks wk == encrypt_1989_unrolled plain ks wk }};
print "  Unroll lemma: PROVED";

// Build simpset with the unroll lemma
let ss = cryptol_ss ();
let ss_with_unroll = addsimps [encrypt_unroll] ss;

print "Verifying Encrypt (compositional with f override, concrete key)...";
// Use goal_eval to fully evaluate both sides, then w4_unint_z3.
// goal_eval_unint keeps f_1989 uninterpreted but normalizes everything else.
Encrypt_ov <- llvm_verify m "Encrypt" [Rot2_ov, f_ov] false Encrypt_spec
    do {
        simplify ss_with_unroll;
        goal_eval_unint ["f_1989"];
        w4_unint_z3 ["f_1989"];
    };
print "  Encrypt: VERIFIED";

// Decrypt specification
let Decrypt_spec : CrucibleSetup () = do {
    // Set up Rot2's static state
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Set up key state globals with concrete test key
    llvm_alloc_global "K";
    llvm_points_to (llvm_global "K") (llvm_term c_subkeys);
    llvm_alloc_global "K89";
    llvm_points_to (llvm_global "K89") (llvm_term c_k89);
    llvm_alloc_global "K1011";
    llvm_points_to (llvm_global "K1011") (llvm_term c_k1011);
    llvm_alloc_global "K1213";
    llvm_points_to (llvm_global "K1213") (llvm_term c_k1213);
    llvm_alloc_global "K1415";
    llvm_points_to (llvm_global "K1415") (llvm_term c_k1415);

    // Input: symbolic 8-byte ciphertext
    cipher_ptr <- llvm_alloc_readonly (llvm_array 8 (llvm_int 8));
    cipher_bytes <- llvm_fresh_var "cipher_bytes" (llvm_array 8 (llvm_int 8));
    llvm_points_to cipher_ptr (llvm_term cipher_bytes);

    // Output: 8-byte plaintext buffer
    plain_ptr <- llvm_alloc (llvm_array 8 (llvm_int 8));

    llvm_execute_func [cipher_ptr, plain_ptr];

    // Post-state: globals unchanged
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Expected plaintext from Cryptol (using C-typed subkeys/whitening keys)
    let expected_plain = {{ decrypt_1989 cipher_bytes c_subkeys (c_k89, c_k1011, c_k1213, c_k1415) }};
    llvm_points_to plain_ptr (llvm_term expected_plain);
};

// Prove the decrypt unroll lemma
print "Proving decrypt unroll lemma...";
decrypt_unroll <- prove_print
    (w4_unint_z3 ["f_1989", "S0", "S1"])
    {{ \cipher ks wk -> decrypt_1989 cipher ks wk == decrypt_1989_unrolled cipher ks wk }};
print "  Decrypt unroll lemma: PROVED";

let ss_with_both = addsimps [encrypt_unroll, decrypt_unroll] ss;

print "Verifying Decrypt (compositional with f override, concrete key)...";
// Same approach as Encrypt: use unroll lemma + goal_eval_unint
Decrypt_ov <- llvm_verify m "Decrypt" [Rot2_ov, f_ov] false Decrypt_spec
    do {
        simplify ss_with_both;
        goal_eval_unint ["f_1989"];
        w4_unint_z3 ["f_1989"];
    };
print "  Decrypt: VERIFIED";
print "";

// ============================================================================
// Stage 7: Symbolic Key Verification
//
// Generalize from concrete test key to fully symbolic key schedule.
// This proves correctness for ALL possible keys, not just the test key.
//
// Symbolic variables:
// - 16 subkeys: [16][32] = 512 bits
// - 4 whitening keys: [64] each = 256 bits (only low 32 bits matter)
// - plaintext/ciphertext: [8][8] = 64 bits
// Total: ~832 bits symbolic
//
// With f_1989 uninterpreted, this should still be tractable.
// ============================================================================

print "=== Stage 7: Symbolic Key Verification ===";
print "";

// Encrypt with symbolic key schedule
let Encrypt_symbolic_key_spec : CrucibleSetup () = do {
    // Set up Rot2's static state
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Symbolic key schedule in globals
    // NOTE: Subkeys are stored as 32-bit unsigned int, but only low 16 bits are meaningful
    // (from the 16-bit key schedule). We verify with full 32-bit symbolic values.
    llvm_alloc_global "K";
    sym_subkeys <- llvm_fresh_var "subkeys" (llvm_array 16 (llvm_int 32));
    llvm_points_to (llvm_global "K") (llvm_term sym_subkeys);

    // Whitening keys: 64-bit HalfWord but only low 32 bits are set by SetKey.
    //
    // NOTE: The zero high bits constraint here is NOT an assumption - it's a
    // VERIFIED PROPERTY from Stage 5 (SetKey). The SetKey postcondition proves
    // that K89/K1011/K1213/K1415 are always `zext wk : [64]` for 32-bit wk.
    // We model that verified postcondition here for compositional reasoning.
    llvm_alloc_global "K89";
    sym_k89_32 <- llvm_fresh_var "k89" (llvm_int 32);
    let sym_k89 = {{ zext sym_k89_32 : [64] }};
    llvm_points_to (llvm_global "K89") (llvm_term sym_k89);

    llvm_alloc_global "K1011";
    sym_k1011_32 <- llvm_fresh_var "k1011" (llvm_int 32);
    let sym_k1011 = {{ zext sym_k1011_32 : [64] }};
    llvm_points_to (llvm_global "K1011") (llvm_term sym_k1011);

    llvm_alloc_global "K1213";
    sym_k1213_32 <- llvm_fresh_var "k1213" (llvm_int 32);
    let sym_k1213 = {{ zext sym_k1213_32 : [64] }};
    llvm_points_to (llvm_global "K1213") (llvm_term sym_k1213);

    llvm_alloc_global "K1415";
    sym_k1415_32 <- llvm_fresh_var "k1415" (llvm_int 32);
    let sym_k1415 = {{ zext sym_k1415_32 : [64] }};
    llvm_points_to (llvm_global "K1415") (llvm_term sym_k1415);

    // Symbolic plaintext
    plain_ptr <- llvm_alloc_readonly (llvm_array 8 (llvm_int 8));
    plain_bytes <- llvm_fresh_var "plain_bytes" (llvm_array 8 (llvm_int 8));
    llvm_points_to plain_ptr (llvm_term plain_bytes);

    // Output buffer
    cipher_ptr <- llvm_alloc (llvm_array 8 (llvm_int 8));

    llvm_execute_func [plain_ptr, cipher_ptr];

    // Post-state: globals unchanged
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Expected: encrypt_1989 with symbolic key schedule
    let expected = {{ encrypt_1989 plain_bytes sym_subkeys (sym_k89, sym_k1011, sym_k1213, sym_k1415) }};
    llvm_points_to cipher_ptr (llvm_term expected);
};

print "Verifying Encrypt (symbolic key, symbolic plaintext)...";
llvm_verify m "Encrypt" [Rot2_ov, f_ov] false Encrypt_symbolic_key_spec
    do {
        simplify ss_with_both;
        goal_eval_unint ["f_1989"];
        w4_unint_z3 ["f_1989"];
    };
print "  Encrypt (symbolic key): VERIFIED";

// Decrypt with symbolic key schedule
let Decrypt_symbolic_key_spec : CrucibleSetup () = do {
    // Set up Rot2's static state
    llvm_alloc_global "Rot2.First";
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_alloc_global "Rot2.RetVal";
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Symbolic key schedule in globals (same constraints as Encrypt)
    llvm_alloc_global "K";
    sym_subkeys <- llvm_fresh_var "subkeys" (llvm_array 16 (llvm_int 32));
    llvm_points_to (llvm_global "K") (llvm_term sym_subkeys);

    // Whitening keys constrained to 32-bit values (zero high bits)
    llvm_alloc_global "K89";
    sym_k89_32 <- llvm_fresh_var "k89" (llvm_int 32);
    let sym_k89 = {{ zext sym_k89_32 : [64] }};
    llvm_points_to (llvm_global "K89") (llvm_term sym_k89);

    llvm_alloc_global "K1011";
    sym_k1011_32 <- llvm_fresh_var "k1011" (llvm_int 32);
    let sym_k1011 = {{ zext sym_k1011_32 : [64] }};
    llvm_points_to (llvm_global "K1011") (llvm_term sym_k1011);

    llvm_alloc_global "K1213";
    sym_k1213_32 <- llvm_fresh_var "k1213" (llvm_int 32);
    let sym_k1213 = {{ zext sym_k1213_32 : [64] }};
    llvm_points_to (llvm_global "K1213") (llvm_term sym_k1213);

    llvm_alloc_global "K1415";
    sym_k1415_32 <- llvm_fresh_var "k1415" (llvm_int 32);
    let sym_k1415 = {{ zext sym_k1415_32 : [64] }};
    llvm_points_to (llvm_global "K1415") (llvm_term sym_k1415);

    // Symbolic ciphertext
    cipher_ptr <- llvm_alloc_readonly (llvm_array 8 (llvm_int 8));
    cipher_bytes <- llvm_fresh_var "cipher_bytes" (llvm_array 8 (llvm_int 8));
    llvm_points_to cipher_ptr (llvm_term cipher_bytes);

    // Output buffer
    plain_ptr <- llvm_alloc (llvm_array 8 (llvm_int 8));

    llvm_execute_func [cipher_ptr, plain_ptr];

    // Post-state: globals unchanged
    llvm_points_to (llvm_global "Rot2.First") (llvm_term {{ 0 : [32] }});
    llvm_points_to (llvm_global "Rot2.RetVal") (llvm_term {{ rot2Table }});

    // Expected: decrypt_1989 with symbolic key schedule
    let expected = {{ decrypt_1989 cipher_bytes sym_subkeys (sym_k89, sym_k1011, sym_k1213, sym_k1415) }};
    llvm_points_to plain_ptr (llvm_term expected);
};

print "Verifying Decrypt (symbolic key, symbolic ciphertext)...";
llvm_verify m "Decrypt" [Rot2_ov, f_ov] false Decrypt_symbolic_key_spec
    do {
        simplify ss_with_both;
        goal_eval_unint ["f_1989"];
        w4_unint_z3 ["f_1989"];
    };
print "  Decrypt (symbolic key): VERIFIED";
print "";

// ============================================================================
// Stage 8: Equivalence to HAC Reference Spec
//
// Final theorem: prove that the 1989 implementation matches the HAC spec
// at the byte level. This closes the verification chain:
//
//   C code  ==  feal8_1989.cry  ==  feal8.cry (HAC)
//           ^                   ^
//     (SAW proof)        (Cryptol proof)
//
// Strategy: Decompose into layers with uninterpreted functions to make
// the proofs tractable. Each layer proves equivalence assuming the layer
// below is equivalent.
// ============================================================================

print "=== Stage 8: HAC Equivalence Proof ===";
print "";

// Test vectors match (concrete) - sanity check
print "Proving test vectors match...";
prove_print z3 {{ test_vectors_match }};
print "  Test vectors: MATCH";

// Layer 1: S-box equivalence (trivially true - same functions imported)
// S0 and S1 are identical between HAC and 1989 specs (imported from FEAL8)

// Layer 2: fK/FK equivalence (with S0/S1 uninterpreted)
// The key schedule functions differ in byte ordering but produce
// byte-swapped equivalent subkeys.
print "Proving fK equivalence (S0/S1 uninterpreted)...";
prove_print (w4_unint_z3 ["S0", "S1"]) {{ \a b -> fK a b == byteSwap32 (FK_1989_32 (byteSwap32 a) (byteSwap32 b)) }};
print "  fK equiv: PROVED";

// Layer 3: f function equivalence (with S0/S1 uninterpreted)
print "Proving f equivalence (S0/S1 uninterpreted)...";
prove_print (w4_unint_z3 ["S0", "S1"]) {{ \a y -> f a y == byteSwap32 (drop`{32} (f_1989 (zext (byteSwap32 a)) (zext (byteSwap16 y)))) }};
print "  f equiv: PROVED";

// Layer 4: Full encrypt equivalence
// Keep S0/S1 uninterpreted, but let SAW evaluate through fK/f.
// This is tractable because the S-boxes are the expensive part.
print "Proving encrypt equivalence to HAC spec (S0/S1 uninterpreted)...";
prove_print (w4_unint_z3 ["S0", "S1"])
    {{ \key plain -> encrypt_equiv_to_HAC key plain }};
print "  Encrypt equiv: PROVED";

print "Proving decrypt equivalence to HAC spec (S0/S1 uninterpreted)...";
prove_print (w4_unint_z3 ["S0", "S1"])
    {{ \key cipher -> decrypt_equiv_to_HAC key cipher }};
print "  Decrypt equiv: PROVED";

print "";

print "=== FEAL-8 1989 Verification Complete ===";
print "";
print "Summary:";
print "  C code verified against feal8_1989.cry (SAW proofs)";
print "  feal8_1989.cry equivalent to feal8.cry HAC spec (Cryptol proofs)";
print "";
print "  Functions verified:";
print "    Rot2 (init + steady-state), S0, S1, f, FK, SetKey, Encrypt, Decrypt";
print "";
print "  Symbolic coverage:";
print "    - Rot2 init: C loop verified to produce correct lookup table";
print "    - SetKey: 64-bit key (all 2^64 keys)";
print "    - Encrypt/Decrypt: 704-bit input (key schedule + plaintext/ciphertext)";
print "    - HAC equivalence: 128-bit input (all 2^128 key/message pairs)";
print "";

/*
 * FEAL-8 1989 Implementation - Cryptol Specification
 *
 * This module provides Cryptol functions that match the byte-level behavior
 * of the 1989 C implementation, which uses little-endian unions.
 *
 * The main feal8.cry contains the HAC-based specification (big-endian).
 * This file contains the 1989-specific little-endian variants for SAW verification.
 */

module FEAL8_1989 where

import FEAL8  // Get S0, S1, ROT2 from the main spec

// ============================================================================
// Little-endian byte manipulation helpers
// ============================================================================

// Convert 4 bytes to 32-bit value (little-endian: byte 0 = LSB)
makeH_le : [4][8] -> [32]
makeH_le bytes = join (reverse bytes)

// Extract bytes from 32-bit value (little-endian order)
dissH_le : [32] -> [4][8]
dissH_le h = reverse (split h)

// Extract byte from 32-bit value by index (little-endian)
byte32 : [32] -> [2] -> [8]
byte32 val i = drop`{24} (val >> (8 * (zext i : [32])))

// ============================================================================
// FK_1989: Key schedule round function (64-bit, little-endian)
//
// Matches the C code's FK function which uses unions on 64-bit HalfWords.
// Only the low 32 bits are meaningful; high 32 bits are undefined in C.
// ============================================================================

FK_1989 : [64] -> [64] -> [64]
FK_1989 aa bb = result
  where
    // Extract low 32 bits (the meaningful part)
    a_low = drop`{32} aa : [32]
    b_low = drop`{32} bb : [32]

    // Extract bytes in little-endian order
    a0 = byte32 a_low 0
    a1 = byte32 a_low 1
    a2 = byte32 a_low 2
    a3 = byte32 a_low 3
    b0 = byte32 b_low 0
    b1 = byte32 b_low 1
    b2 = byte32 b_low 2
    b3 = byte32 b_low 3

    // C code logic
    fk1_init = a1 ^ a0
    fk2_init = a2 ^ a3
    fk1 = S1 fk1_init (fk2_init ^ b0)
    fk2 = S0 fk2_init (fk1 ^ b1)
    r0 = S0 a0 (fk1 ^ b2)
    r1 = fk1
    r2 = fk2
    r3 = S1 a3 (fk2 ^ b3)

    // Reassemble (high 32 bits are zero, matching zext behavior)
    result = zext (r3 # r2 # r1 # r0) : [64]

// ============================================================================
// f_1989: Round function (64-bit input, 32-bit subkey, little-endian)
// ============================================================================

f_1989 : [64] -> [32] -> [64]
f_1989 aa bb = result
  where
    // Extract low 32 bits of AA
    a_low = drop`{32} aa : [32]

    // Extract bytes in little-endian order
    a0 = byte32 a_low 0
    a1 = byte32 a_low 1
    a2 = byte32 a_low 2
    a3 = byte32 a_low 3
    b0 = byte32 bb 0
    b1 = byte32 bb 1

    // C code logic
    f1_init = a1 ^ b0 ^ a0
    f2_init = a2 ^ b1 ^ a3
    f1 = S1 f1_init f2_init
    f2 = S0 f2_init f1
    r0 = S0 a0 f1
    r1 = f1
    r2 = f2
    r3 = S1 a3 f2

    // Reassemble in little-endian order
    result = zext (r3 # r2 # r1 # r0) : [64]

// ============================================================================
// keySchedule_1989: Full key schedule matching C's SetKey function
//
// Input: 8 bytes (64-bit key as byte array)
// Output: 16 subkeys in little-endian format (as stored in C's K[16])
// ============================================================================

keySchedule_1989 : [8][8] -> [16][16]
keySchedule_1989 key_bytes = subkeys
  where
    // Split key into A and B, zero-extend to 64-bit
    a_init : [64]
    a_init = zext (makeH_le (take`{4} key_bytes))
    b_init : [64]
    b_init = zext (makeH_le (drop`{4} key_bytes))

    // Initial state: (D, A, B) = (0, key_left, key_right)
    init : ([64], [64], [64])
    init = (0, a_init, b_init)

    // One iteration of the key schedule loop
    step : ([64], [64], [64]) -> ([64], [64], [64])
    step (d, a, b) = (a, b, newB)
      where
        newB = FK_1989 a (b ^ d)

    // Run 8 iterations
    states = [init] # [ step s | s <- take`{8} states ]

    // Extract subkeys from each iteration's B value
    extractSubkeys : [64] -> ([16], [16])
    extractSubkeys b_val = (k0, k1)
      where
        // Extract low 32 bits, then get bytes in little-endian order
        bytes = dissH_le (drop`{32} b_val)
        // C stores Q.All = (Byte[1] << 8) | Byte[0] on little-endian
        // As Cryptol [16]: join [high_byte, low_byte]
        k0 = join [bytes@1, bytes@0]
        k1 = join [bytes@3, bytes@2]

    // Extract all 16 subkeys
    subkeys = join [ [k0, k1]
                   | (_, _, b) <- tail states
                   | (k0, k1) <- [ extractSubkeys b | (_, _, b) <- tail states ] ]

// ============================================================================
// MakeH2: Convert two 16-bit subkeys to 32-bit whitening key
// ============================================================================

makeH2_le : [16] -> [16] -> [32]
makeH2_le q0 q1 = result
  where
    // DissQ1 extracts bytes in little-endian order
    b0 = drop`{8} q0 : [8]   // low byte of q0
    b1 = take`{8} q0 : [8]   // high byte of q0
    b2 = drop`{8} q1 : [8]   // low byte of q1
    b3 = take`{8} q1 : [8]   // high byte of q1
    result = makeH_le [b0, b1, b2, b3]

// Compute whitening keys from subkey array
computeWhiteningKeys : [16][16] -> ([32], [32], [32], [32])
computeWhiteningKeys ks = (k89, k1011, k1213, k1415)
  where
    k89    = makeH2_le (ks@8)  (ks@9)
    k1011  = makeH2_le (ks@10) (ks@11)
    k1213  = makeH2_le (ks@12) (ks@13)
    k1415  = makeH2_le (ks@14) (ks@15)

// ============================================================================
// Test properties
// ============================================================================

// Expected subkeys from C output for key 0x0123456789abcdef
testKeyBytes : [8][8]
testKeyBytes = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]

expected_C_subkeys : [16][16]
expected_C_subkeys = [0x3bdf, 0x36ca, 0x7cf1, 0xec1a, 0xa545, 0xc7b9, 0xeb26, 0x25ad,
                      0x2a8b, 0xb7ec, 0x50ac, 0x4c9d, 0xcd22, 0x9b47, 0xd5a8, 0xb50c]

property keySchedule_1989_correct =
    keySchedule_1989 testKeyBytes == expected_C_subkeys

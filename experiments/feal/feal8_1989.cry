/*
 * FEAL-8 1989 Implementation - Cryptol Specification
 *
 * This module provides Cryptol functions that match the byte-level behavior
 * of the 1989 C implementation, which uses little-endian unions.
 *
 * The main feal8.cry contains the HAC-based specification (big-endian).
 * This file contains the 1989-specific little-endian variants for SAW verification.
 */

module FEAL8_1989 where

import FEAL8  // Get S0, S1, ROT2 from the main spec

// ============================================================================
// Little-endian byte manipulation helpers
// ============================================================================

// Convert 4 bytes to 32-bit value (little-endian: byte 0 = LSB)
makeH_le : [4][8] -> [32]
makeH_le bytes = join (reverse bytes)

// Extract bytes from 32-bit value (little-endian order)
dissH_le : [32] -> [4][8]
dissH_le h = reverse (split h)

// Extract byte from 32-bit value by index (little-endian)
byte32 : [32] -> [2] -> [8]
byte32 val i = drop`{24} (val >> (8 * (zext i : [32])))

// ============================================================================
// FK_1989: Key schedule round function (64-bit, little-endian)
//
// Matches the C code's FK function which uses unions on 64-bit HalfWords.
// Only the low 32 bits are meaningful; high 32 bits are undefined in C.
// ============================================================================

FK_1989 : [64] -> [64] -> [64]
FK_1989 aa bb = result
  where
    // Extract low 32 bits (the meaningful part)
    a_low = drop`{32} aa : [32]
    b_low = drop`{32} bb : [32]

    // Extract bytes in little-endian order
    a0 = byte32 a_low 0
    a1 = byte32 a_low 1
    a2 = byte32 a_low 2
    a3 = byte32 a_low 3
    b0 = byte32 b_low 0
    b1 = byte32 b_low 1
    b2 = byte32 b_low 2
    b3 = byte32 b_low 3

    // C code logic
    fk1_init = a1 ^ a0
    fk2_init = a2 ^ a3
    fk1 = S1 fk1_init (fk2_init ^ b0)
    fk2 = S0 fk2_init (fk1 ^ b1)
    r0 = S0 a0 (fk1 ^ b2)
    r1 = fk1
    r2 = fk2
    r3 = S1 a3 (fk2 ^ b3)

    // Reassemble (high 32 bits are zero, matching zext behavior)
    result = zext (r3 # r2 # r1 # r0) : [64]

// ============================================================================
// f_1989: Round function (64-bit input, 32-bit subkey, little-endian)
// ============================================================================

f_1989 : [64] -> [32] -> [64]
f_1989 aa bb = result
  where
    // Extract low 32 bits of AA
    a_low = drop`{32} aa : [32]

    // Extract bytes in little-endian order
    a0 = byte32 a_low 0
    a1 = byte32 a_low 1
    a2 = byte32 a_low 2
    a3 = byte32 a_low 3
    b0 = byte32 bb 0
    b1 = byte32 bb 1

    // C code logic
    f1_init = a1 ^ b0 ^ a0
    f2_init = a2 ^ b1 ^ a3
    f1 = S1 f1_init f2_init
    f2 = S0 f2_init f1
    r0 = S0 a0 f1
    r1 = f1
    r2 = f2
    r3 = S1 a3 f2

    // Reassemble in little-endian order
    result = zext (r3 # r2 # r1 # r0) : [64]

// ============================================================================
// keySchedule_1989: Full key schedule matching C's SetKey function
//
// Input: 8 bytes (64-bit key as byte array)
// Output: 16 subkeys in little-endian format (as stored in C's K[16])
// ============================================================================

keySchedule_1989 : [8][8] -> [16][16]
keySchedule_1989 key_bytes = subkeys
  where
    // Split key into A and B, zero-extend to 64-bit
    a_init : [64]
    a_init = zext (makeH_le (take`{4} key_bytes))
    b_init : [64]
    b_init = zext (makeH_le (drop`{4} key_bytes))

    // Initial state: (D, A, B) = (0, key_left, key_right)
    init : ([64], [64], [64])
    init = (0, a_init, b_init)

    // One iteration of the key schedule loop
    step : ([64], [64], [64]) -> ([64], [64], [64])
    step (d, a, b) = (a, b, newB)
      where
        newB = FK_1989 a (b ^ d)

    // Run 8 iterations
    states = [init] # [ step s | s <- take`{8} states ]

    // Extract subkeys from each iteration's B value
    extractSubkeys : [64] -> ([16], [16])
    extractSubkeys b_val = (k0, k1)
      where
        // Extract low 32 bits, then get bytes in little-endian order
        bytes = dissH_le (drop`{32} b_val)
        // C stores Q.All = (Byte[1] << 8) | Byte[0] on little-endian
        // As Cryptol [16]: join [high_byte, low_byte]
        k0 = join [bytes@1, bytes@0]
        k1 = join [bytes@3, bytes@2]

    // Extract all 16 subkeys
    subkeys = join [ [k0, k1]
                   | (_, _, b) <- tail states
                   | (k0, k1) <- [ extractSubkeys b | (_, _, b) <- tail states ] ]

// ============================================================================
// MakeH2: Convert two 16-bit subkeys to 32-bit whitening key
// ============================================================================

makeH2_le : [16] -> [16] -> [32]
makeH2_le q0 q1 = result
  where
    // DissQ1 extracts bytes in little-endian order
    b0 = drop`{8} q0 : [8]   // low byte of q0
    b1 = take`{8} q0 : [8]   // high byte of q0
    b2 = drop`{8} q1 : [8]   // low byte of q1
    b3 = take`{8} q1 : [8]   // high byte of q1
    result = makeH_le [b0, b1, b2, b3]

// Compute whitening keys from subkey array
computeWhiteningKeys : [16][16] -> ([32], [32], [32], [32])

// ============================================================================
// normalize64: Canonicalize 64-bit value term structure
//
// SAW's symbolic execution of union-based byte access creates terms like:
//   append(append(..., slice(val, 24-31)), slice(val, 16-23)), ...)
// This is semantically equivalent to val (when high 32 bits are zero), but
// creates different term structure than Cryptol's zext/join operations.
//
// This function explicitly matches SAW's canonicalization:
// 1. Extract low 32 bits
// 2. Split into bytes (little-endian)
// 3. Reassemble with zero high bits
//
// Used in encrypt_1989/decrypt_1989 to match SAW's term structure for
// compositional verification with f_1989 uninterpreted.
// ============================================================================
normalize64 : [64] -> [64]
normalize64 val = zext (makeH_le (dissH_le (drop`{32} val)))

computeWhiteningKeys ks = (k89, k1011, k1213, k1415)
  where
    k89    = makeH2_le (ks@8)  (ks@9)
    k1011  = makeH2_le (ks@10) (ks@11)
    k1213  = makeH2_le (ks@12) (ks@13)
    k1415  = makeH2_le (ks@14) (ks@15)

// ============================================================================
// encrypt_1989: Encryption matching C's Encrypt function
//
// Takes pre-computed subkeys and whitening keys (as produced by SetKey)
// Input: 8-byte plaintext, 16 subkeys, 4 whitening keys (as 64-bit C values)
// Output: 8-byte ciphertext
//
// NOTE: Uses 64-bit values throughout to match C's HalfWord type exactly.
// This enables SAW's compositional verification with f_ov override.
// (Temporary: debugging step toward fully symbolic key verification)
// ============================================================================

encrypt_1989 : [8][8] -> [16][32] -> ([64], [64], [64], [64]) -> [8][8]
encrypt_1989 plain_bytes ks (k89, k1011, k1213, k1415) = cipher_bytes
  where
    // Read plaintext as two 64-bit HalfWords (matching C's MakeH1)
    // MakeH1 returns 64-bit with low 32 bits from bytes, high 32 = 0
    l_init : [64]
    l_init = zext (makeH_le (take`{4} plain_bytes))
    r_init : [64]
    r_init = zext (makeH_le (drop`{4} plain_bytes))

    // Initial whitening with normalize64 to match SAW's term structure
    // SAW normalizes after each XOR due to union byte access patterns
    l0 = normalize64 (l_init ^ k89)
    r0_tmp = normalize64 (r_init ^ k1011)
    r0 = normalize64 (l0 ^ r0_tmp)

    // 8 Feistel rounds using 64-bit values
    // Note: SAW does NOT normalize between rounds - only the initial state
    round : ([64], [64], [4]) -> ([64], [64])
    round (l, r, i) = (r, newR)
      where
        // K[i] is 32-bit in C (zext'd from 16-bit subkey)
        k_i = ks @ i
        // f_1989 takes [64] and [32], returns [64]
        f_result = f_1989 r k_i
        newR = l ^ f_result

    // Run 8 rounds
    states : [9]([64], [64])
    states = [(l0, r0)] # [ round (l, r, i) | (l, r) <- take`{8} states | i <- [0..7] ]

    (l8, r8) = states @ 8

    // Final operations (all 64-bit)
    l8' = l8 ^ r8
    r_out = r8 ^ k1213
    l_out = l8' ^ k1415

    // Output: DissH1(R, Cipher), DissH1(L, Cipher+4) - extract low 32 bits
    cipher_bytes = dissH_le (drop`{32} r_out) # dissH_le (drop`{32} l_out)

// ============================================================================
// decrypt_1989: Decryption matching C's Decrypt function
//
// Takes pre-computed subkeys and whitening keys (as produced by SetKey)
// Input: 8-byte ciphertext, 16 subkeys, 4 whitening keys (as 64-bit C values)
// Output: 8-byte plaintext
//
// NOTE: Uses 64-bit values throughout to match C's HalfWord type exactly.
// ============================================================================

decrypt_1989 : [8][8] -> [16][32] -> ([64], [64], [64], [64]) -> [8][8]
decrypt_1989 cipher_bytes ks (k89, k1011, k1213, k1415) = plain_bytes
  where
    // Read ciphertext as 64-bit HalfWords: R from bytes 0-3, L from bytes 4-7
    r_init : [64]
    r_init = zext (makeH_le (take`{4} cipher_bytes))
    l_init : [64]
    l_init = zext (makeH_le (drop`{4} cipher_bytes))

    // Initial "whitening" with normalize64 to match SAW's term structure
    // (reversed from encrypt's final operations)
    r0 = normalize64 (r_init ^ k1213)
    l0 = normalize64 (r0 ^ normalize64 (l_init ^ k1415))

    // 8 Feistel rounds in reverse (K7 down to K0)
    round : ([64], [64], [4]) -> ([64], [64])
    round (l, r, i) = (newL, l)
      where
        k_i = ks @ i
        f_result = f_1989 l k_i
        newL = r ^ f_result

    // Run 8 rounds with reversed key order
    states : [9]([64], [64])
    states = [(l0, r0)] # [ round (l, r, i) | (l, r) <- take`{8} states | i <- [7, 6 .. 0] ]

    (l8, r8) = states @ 8

    // Final operations (reversed from encrypt's initial operations)
    r8' = r8 ^ l8
    r_out = r8' ^ k1011
    l_out = l8 ^ k89

    // Output: DissH1(L, Plain), DissH1(R, Plain+4) - extract low 32 bits
    plain_bytes = dissH_le (drop`{32} l_out) # dissH_le (drop`{32} r_out)

// Convenience: encrypt with key bytes (computes key schedule internally)
// Converts 16-bit subkeys to 32-bit and 32-bit whitening keys to 64-bit
encryptWithKey_1989 : [8][8] -> [8][8] -> [8][8]
encryptWithKey_1989 key_bytes plain_bytes = encrypt_1989 plain_bytes ks64 wk64
  where
    ks = keySchedule_1989 key_bytes
    ks64 = [ zext k : [32] | k <- ks ]
    wk = computeWhiteningKeys ks
    wk64 = (zext wk.0, zext wk.1, zext wk.2, zext wk.3)

// Convenience: decrypt with key bytes
decryptWithKey_1989 : [8][8] -> [8][8] -> [8][8]
decryptWithKey_1989 key_bytes cipher_bytes = decrypt_1989 cipher_bytes ks64 wk64
  where
    ks = keySchedule_1989 key_bytes
    ks64 = [ zext k : [32] | k <- ks ]
    wk = computeWhiteningKeys ks
    wk64 = (zext wk.0, zext wk.1, zext wk.2, zext wk.3)

// ============================================================================
// Test properties
// ============================================================================

// Round-trip property
property roundTrip_1989 key plain =
    decryptWithKey_1989 key (encryptWithKey_1989 key plain) == plain

// Test vector from C output
testPlainBytes : [8][8]
testPlainBytes = [0, 0, 0, 0, 0, 0, 0, 0]

expectedCipherBytes : [8][8]
expectedCipherBytes = [0xce, 0xef, 0x2c, 0x86, 0xf2, 0x49, 0x07, 0x52]

property encryptTestVector =
    encryptWithKey_1989 testKeyBytes testPlainBytes == expectedCipherBytes

// Expected subkeys from C output for key 0x0123456789abcdef
testKeyBytes : [8][8]
testKeyBytes = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]

expected_C_subkeys : [16][16]
expected_C_subkeys = [0x3bdf, 0x36ca, 0x7cf1, 0xec1a, 0xa545, 0xc7b9, 0xeb26, 0x25ad,
                      0x2a8b, 0xb7ec, 0x50ac, 0x4c9d, 0xcd22, 0x9b47, 0xd5a8, 0xb50c]

property keySchedule_1989_correct =
    keySchedule_1989 testKeyBytes == expected_C_subkeys

// ============================================================================
// Explicit unroll for encrypt_1989 - used for SAW simpset matching
//
// This defines the 8 rounds explicitly without recursion, matching how SAW
// builds terms through symbolic execution.
// ============================================================================

// Explicit 8-round encryption matching SAW's term structure
encrypt_1989_unrolled : [8][8] -> [16][32] -> ([64], [64], [64], [64]) -> [8][8]
encrypt_1989_unrolled plain_bytes ks (k89, k1011, k1213, k1415) = cipher_bytes
  where
    // Initial state with SAW's normalize pattern
    l_init = zext (makeH_le (take`{4} plain_bytes))
    r_init = zext (makeH_le (drop`{4} plain_bytes))
    l0 = normalize64 (l_init ^ k89)
    r0 = normalize64 (l0 ^ normalize64 (r_init ^ k1011))

    // Round 0
    r1 = l0 ^ f_1989 r0 (ks@0)
    l1 = r0

    // Round 1
    r2 = l1 ^ f_1989 r1 (ks@1)
    l2 = r1

    // Round 2
    r3 = l2 ^ f_1989 r2 (ks@2)
    l3 = r2

    // Round 3
    r4 = l3 ^ f_1989 r3 (ks@3)
    l4 = r3

    // Round 4
    r5 = l4 ^ f_1989 r4 (ks@4)
    l5 = r4

    // Round 5
    r6 = l5 ^ f_1989 r5 (ks@5)
    l6 = r5

    // Round 6
    r7 = l6 ^ f_1989 r6 (ks@6)
    l7 = r6

    // Round 7
    r8 = l7 ^ f_1989 r7 (ks@7)
    l8 = r7

    // Final operations
    r_out = r8 ^ k1213
    l_out = (l8 ^ r8) ^ k1415

    // Output
    cipher_bytes = dissH_le (drop`{32} r_out) # dissH_le (drop`{32} l_out)

// Lemma: encrypt_1989 equals the unrolled form
// This will be used as a simpset rule in SAW
property encrypt_unroll_lemma plain_bytes ks wk =
    encrypt_1989 plain_bytes ks wk == encrypt_1989_unrolled plain_bytes ks wk

// ============================================================================
// Explicit unroll for decrypt_1989
// ============================================================================

decrypt_1989_unrolled : [8][8] -> [16][32] -> ([64], [64], [64], [64]) -> [8][8]
decrypt_1989_unrolled cipher_bytes ks (k89, k1011, k1213, k1415) = plain_bytes
  where
    // Initial state with SAW's normalize pattern (reversed from encrypt)
    r_init = zext (makeH_le (take`{4} cipher_bytes))
    l_init = zext (makeH_le (drop`{4} cipher_bytes))
    r0 = normalize64 (r_init ^ k1213)
    l0 = normalize64 (r0 ^ normalize64 (l_init ^ k1415))

    // Round 0 (using K7)
    l1 = r0 ^ f_1989 l0 (ks@7)
    r1 = l0

    // Round 1 (using K6)
    l2 = r1 ^ f_1989 l1 (ks@6)
    r2 = l1

    // Round 2 (using K5)
    l3 = r2 ^ f_1989 l2 (ks@5)
    r3 = l2

    // Round 3 (using K4)
    l4 = r3 ^ f_1989 l3 (ks@4)
    r4 = l3

    // Round 4 (using K3)
    l5 = r4 ^ f_1989 l4 (ks@3)
    r5 = l4

    // Round 5 (using K2)
    l6 = r5 ^ f_1989 l5 (ks@2)
    r6 = l5

    // Round 6 (using K1)
    l7 = r6 ^ f_1989 l6 (ks@1)
    r7 = l6

    // Round 7 (using K0)
    l8 = r7 ^ f_1989 l7 (ks@0)
    r8 = l7

    // Final operations (reversed from encrypt's initial operations)
    l_out = l8 ^ k89
    r_out = (r8 ^ l8) ^ k1011

    // Output
    plain_bytes = dissH_le (drop`{32} l_out) # dissH_le (drop`{32} r_out)

property decrypt_unroll_lemma cipher_bytes ks wk =
    decrypt_1989 cipher_bytes ks wk == decrypt_1989_unrolled cipher_bytes ks wk

// ============================================================================
// Equivalence to HAC Reference Spec
//
// This is the key theorem: the 1989 implementation is equivalent to the
// HAC-based reference spec when both operate on raw bytes.
//
// The internal representations differ (little-endian vs big-endian word
// ordering), but the byte-level input/output behavior is identical.
// ============================================================================

// Convert between byte array and 64-bit block (big-endian, HAC convention)
toBlock : [8][8] -> [64]
toBlock bytes = join bytes

fromBlock : [64] -> [8][8]
fromBlock block = split block

// Main equivalence theorem: 1989 encrypt == HAC encrypt at byte level
property encrypt_equiv_to_HAC key_bytes plain_bytes =
    encryptWithKey_1989 key_bytes plain_bytes == fromBlock (encrypt (toBlock key_bytes) (toBlock plain_bytes))

// Main equivalence theorem: 1989 decrypt == HAC decrypt at byte level
property decrypt_equiv_to_HAC key_bytes cipher_bytes =
    decryptWithKey_1989 key_bytes cipher_bytes == fromBlock (decrypt (toBlock key_bytes) (toBlock cipher_bytes))

// Byte-swap functions for equivalence proofs
byteSwap16 : [16] -> [16]
byteSwap16 x = join (reverse (split`{2} x : [2][8]))

byteSwap32 : [32] -> [32]
byteSwap32 x = join (reverse (split`{4} x : [4][8]))

// 32-bit version of FK_1989 for equivalence proofs
// (The main FK_1989 uses 64-bit to match C's HalfWord type)
FK_1989_32 : [32] -> [32] -> [32]
FK_1989_32 aa bb = drop`{32} (FK_1989 (zext aa) (zext bb))

// Subkey relationship: HAC and 1989 subkeys are byte-swapped
property subkey_equiv key_bytes =
    and [ hac_subkeys @ i == byteSwap16 (keySchedule_1989 key_bytes @ i) | i <- [0..15] : [16][4] ]
  where
    hac_subkeys = keySchedule (toBlock key_bytes)

// Verify test vectors match between specs
property test_vectors_match =
    toBlock expectedCipherBytes == testCiphertext
  where
    testCiphertext = encrypt (toBlock testKeyBytes) (toBlock testPlainBytes)

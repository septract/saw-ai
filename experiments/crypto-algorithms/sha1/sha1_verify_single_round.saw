// SAW verification of SHA1 single round functions
// Uses verified primitives as overrides for compositional verification

m <- llvm_load_module "sha1_single_round.bc";

// ============================================================
// Cryptol specs
// ============================================================

let {{
    spec_ch : [32] -> [32] -> [32] -> [32]
    spec_ch b c d = (b && c) ^ (~b && d)

    spec_parity : [32] -> [32] -> [32] -> [32]
    spec_parity b c d = b ^ c ^ d

    spec_maj : [32] -> [32] -> [32] -> [32]
    spec_maj b c d = (b && c) ^ (b && d) ^ (c && d)

    // Single round with Ch
    spec_round_ch : ([32],[32],[32],[32],[32]) -> [32] -> [32] -> ([32],[32],[32],[32],[32])
    spec_round_ch (a, b, c, d, e) w k = (a', b', c', d', e')
      where
        t = (a <<< 5) + spec_ch b c d + e + k + w
        a' = t
        b' = a
        c' = b <<< 30
        d' = c
        e' = d

    // Single round with Parity
    spec_round_parity : ([32],[32],[32],[32],[32]) -> [32] -> [32] -> ([32],[32],[32],[32],[32])
    spec_round_parity (a, b, c, d, e) w k = (a', b', c', d', e')
      where
        t = (a <<< 5) + spec_parity b c d + e + k + w
        a' = t
        b' = a
        c' = b <<< 30
        d' = c
        e' = d

    // Single round with Maj
    spec_round_maj : ([32],[32],[32],[32],[32]) -> [32] -> [32] -> ([32],[32],[32],[32],[32])
    spec_round_maj (a, b, c, d, e) w k = (a', b', c', d', e')
      where
        t = (a <<< 5) + spec_maj b c d + e + k + w
        a' = t
        b' = a
        c' = b <<< 30
        d' = c
        e' = d
}};

// ============================================================
// First: Verify the primitive specs (for overrides)
// ============================================================

let sha1_ch_spec = do {
    b <- llvm_fresh_var "b" (llvm_int 32);
    c <- llvm_fresh_var "c" (llvm_int 32);
    d <- llvm_fresh_var "d" (llvm_int 32);
    llvm_execute_func [llvm_term b, llvm_term c, llvm_term d];
    llvm_return (llvm_term {{ spec_ch b c d }});
};

let sha1_parity_spec = do {
    b <- llvm_fresh_var "b" (llvm_int 32);
    c <- llvm_fresh_var "c" (llvm_int 32);
    d <- llvm_fresh_var "d" (llvm_int 32);
    llvm_execute_func [llvm_term b, llvm_term c, llvm_term d];
    llvm_return (llvm_term {{ spec_parity b c d }});
};

let sha1_maj_spec = do {
    b <- llvm_fresh_var "b" (llvm_int 32);
    c <- llvm_fresh_var "c" (llvm_int 32);
    d <- llvm_fresh_var "d" (llvm_int 32);
    llvm_execute_func [llvm_term b, llvm_term c, llvm_term d];
    llvm_return (llvm_term {{ spec_maj b c d }});
};

print "=== SHA1 Single Round Verification ===";
print "";

print "Step 1: Verify primitives...";
ch_ov <- llvm_verify m "sha1_ch" [] false sha1_ch_spec z3;
parity_ov <- llvm_verify m "sha1_parity" [] false sha1_parity_spec z3;
maj_ov <- llvm_verify m "sha1_maj" [] false sha1_maj_spec z3;
print "Primitives verified!";
print "";

// ============================================================
// Verify sha1_round_ch using ch_ov as override
// Input: state (160 bits) + w (32 bits) + k (32 bits) = 224 bits
// ============================================================

let sha1_round_ch_spec = do {
    // Return struct (sret)
    ret_ptr <- llvm_alloc (llvm_struct "struct.SHA1_STATE");

    // Input state (passed by pointer due to ABI)
    input_ptr <- llvm_alloc (llvm_struct "struct.SHA1_STATE");
    a <- llvm_fresh_var "a" (llvm_int 32);
    b <- llvm_fresh_var "b" (llvm_int 32);
    c <- llvm_fresh_var "c" (llvm_int 32);
    d <- llvm_fresh_var "d" (llvm_int 32);
    e <- llvm_fresh_var "e" (llvm_int 32);
    llvm_points_to (llvm_field input_ptr "a") (llvm_term a);
    llvm_points_to (llvm_field input_ptr "b") (llvm_term b);
    llvm_points_to (llvm_field input_ptr "c") (llvm_term c);
    llvm_points_to (llvm_field input_ptr "d") (llvm_term d);
    llvm_points_to (llvm_field input_ptr "e") (llvm_term e);

    // Message word and constant
    w <- llvm_fresh_var "w" (llvm_int 32);
    k <- llvm_fresh_var "k" (llvm_int 32);

    llvm_execute_func [ret_ptr, input_ptr, llvm_term w, llvm_term k];

    // Expected output
    let result = {{ spec_round_ch (a, b, c, d, e) w k }};
    llvm_points_to (llvm_field ret_ptr "a") (llvm_term {{ result.0 }});
    llvm_points_to (llvm_field ret_ptr "b") (llvm_term {{ result.1 }});
    llvm_points_to (llvm_field ret_ptr "c") (llvm_term {{ result.2 }});
    llvm_points_to (llvm_field ret_ptr "d") (llvm_term {{ result.3 }});
    llvm_points_to (llvm_field ret_ptr "e") (llvm_term {{ result.4 }});
};

print "Step 2: Verify sha1_round_ch (224 bits symbolic)...";
print "Using sha1_ch as override (compositional)";
round_ch_ov <- time (llvm_verify m "sha1_round_ch" [ch_ov] false sha1_round_ch_spec z3);
print "SUCCESS: sha1_round_ch verified!";
print "";

// ============================================================
// Verify sha1_round_parity
// ============================================================

let sha1_round_parity_spec = do {
    ret_ptr <- llvm_alloc (llvm_struct "struct.SHA1_STATE");
    input_ptr <- llvm_alloc (llvm_struct "struct.SHA1_STATE");
    a <- llvm_fresh_var "a" (llvm_int 32);
    b <- llvm_fresh_var "b" (llvm_int 32);
    c <- llvm_fresh_var "c" (llvm_int 32);
    d <- llvm_fresh_var "d" (llvm_int 32);
    e <- llvm_fresh_var "e" (llvm_int 32);
    llvm_points_to (llvm_field input_ptr "a") (llvm_term a);
    llvm_points_to (llvm_field input_ptr "b") (llvm_term b);
    llvm_points_to (llvm_field input_ptr "c") (llvm_term c);
    llvm_points_to (llvm_field input_ptr "d") (llvm_term d);
    llvm_points_to (llvm_field input_ptr "e") (llvm_term e);
    w <- llvm_fresh_var "w" (llvm_int 32);
    k <- llvm_fresh_var "k" (llvm_int 32);

    llvm_execute_func [ret_ptr, input_ptr, llvm_term w, llvm_term k];

    let result = {{ spec_round_parity (a, b, c, d, e) w k }};
    llvm_points_to (llvm_field ret_ptr "a") (llvm_term {{ result.0 }});
    llvm_points_to (llvm_field ret_ptr "b") (llvm_term {{ result.1 }});
    llvm_points_to (llvm_field ret_ptr "c") (llvm_term {{ result.2 }});
    llvm_points_to (llvm_field ret_ptr "d") (llvm_term {{ result.3 }});
    llvm_points_to (llvm_field ret_ptr "e") (llvm_term {{ result.4 }});
};

print "Step 3: Verify sha1_round_parity (224 bits symbolic)...";
round_parity_ov <- time (llvm_verify m "sha1_round_parity" [parity_ov] false sha1_round_parity_spec z3);
print "SUCCESS: sha1_round_parity verified!";
print "";

// ============================================================
// Verify sha1_round_maj
// ============================================================

let sha1_round_maj_spec = do {
    ret_ptr <- llvm_alloc (llvm_struct "struct.SHA1_STATE");
    input_ptr <- llvm_alloc (llvm_struct "struct.SHA1_STATE");
    a <- llvm_fresh_var "a" (llvm_int 32);
    b <- llvm_fresh_var "b" (llvm_int 32);
    c <- llvm_fresh_var "c" (llvm_int 32);
    d <- llvm_fresh_var "d" (llvm_int 32);
    e <- llvm_fresh_var "e" (llvm_int 32);
    llvm_points_to (llvm_field input_ptr "a") (llvm_term a);
    llvm_points_to (llvm_field input_ptr "b") (llvm_term b);
    llvm_points_to (llvm_field input_ptr "c") (llvm_term c);
    llvm_points_to (llvm_field input_ptr "d") (llvm_term d);
    llvm_points_to (llvm_field input_ptr "e") (llvm_term e);
    w <- llvm_fresh_var "w" (llvm_int 32);
    k <- llvm_fresh_var "k" (llvm_int 32);

    llvm_execute_func [ret_ptr, input_ptr, llvm_term w, llvm_term k];

    let result = {{ spec_round_maj (a, b, c, d, e) w k }};
    llvm_points_to (llvm_field ret_ptr "a") (llvm_term {{ result.0 }});
    llvm_points_to (llvm_field ret_ptr "b") (llvm_term {{ result.1 }});
    llvm_points_to (llvm_field ret_ptr "c") (llvm_term {{ result.2 }});
    llvm_points_to (llvm_field ret_ptr "d") (llvm_term {{ result.3 }});
    llvm_points_to (llvm_field ret_ptr "e") (llvm_term {{ result.4 }});
};

print "Step 4: Verify sha1_round_maj (224 bits symbolic)...";
round_maj_ov <- time (llvm_verify m "sha1_round_maj" [maj_ov] false sha1_round_maj_spec z3);
print "SUCCESS: sha1_round_maj verified!";
print "";

print "=== All single round functions verified! ===";
print "";
print "Summary:";
print "- sha1_ch, sha1_parity, sha1_maj: verified (96 bits each)";
print "- sha1_round_ch: verified (224 bits) using sha1_ch override";
print "- sha1_round_parity: verified (224 bits) using sha1_parity override";
print "- sha1_round_maj: verified (224 bits) using sha1_maj override";

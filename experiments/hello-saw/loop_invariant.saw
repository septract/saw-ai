/*
 * Loop Invariant Verification Examples
 *
 * FINDING: ALL live variables at the breakpoint MUST be passed to the
 * breakpoint function. This is a requirement of SAW's breakpoint mechanism.
 *
 * Run: saw loop_invariant.saw
 */

print "=== Loop Invariant Verification Examples ===";
print "";

import "accumulator.cry";

m <- llvm_load_module "loop_invariant.bc";

// Helper: allocate and initialize a pointer to a fresh variable
let ptr_to_fresh name ty = do {
    p <- llvm_alloc ty;
    x <- llvm_fresh_var name ty;
    llvm_points_to p (llvm_term x);
    return (p, x);
};

// ============================================================
// Example 1: add2 - Simple breakpoint (no loop)
// ============================================================

print "--- Example 1: add2 (simple breakpoint) ---";

let add2_spec = do {
    x <- llvm_fresh_var "x" (llvm_int 64);
    llvm_execute_func [llvm_term x];
    llvm_return (llvm_term {{ x + 2 }});
};

let inv_spec = do {
    (px, x) <- ptr_to_fresh "x" (llvm_int 64);
    llvm_execute_func [px];
    llvm_return (llvm_term {{ x + 1 }});
};

inv <- llvm_verify m "__breakpoint__inv#add2" [] false inv_spec z3;
print "  Breakpoint VERIFIED";
llvm_verify m "add2" [inv] false add2_spec z3;
print "  add2 VERIFIED";
print "";

// ============================================================
// Example 2: count_n - Basic loop with invariant
// ============================================================

print "--- Example 2: count_n (loop invariant) ---";

let count_n_spec = do {
    n <- llvm_fresh_var "n" (llvm_int 64);
    llvm_execute_func [llvm_term n];
    llvm_return (llvm_term n);
};

// Invariant: c + (n - i) = final result
// At start: c=0, i=0, so result = 0 + (n - 0) = n
// At end: c=n, i=n, so result = n + (n - n) = n
let count_inv_spec = do {
    (pn, n) <- ptr_to_fresh "n" (llvm_int 64);
    (pc, c) <- ptr_to_fresh "c" (llvm_int 64);
    (pi, i) <- ptr_to_fresh "i" (llvm_int 64);
    llvm_precond {{ 0 <= i /\ i <= n }};
    llvm_execute_func [pn, pc, pi];
    llvm_return (llvm_term {{ c + (n - i) }});
};

count_inv <- llvm_unsafe_assume_spec m "__breakpoint__count_inv#count_n" count_inv_spec;
print "  Invariant assumed";
llvm_verify m "__breakpoint__count_inv#count_n" [count_inv] false count_inv_spec z3;
print "  Invariant preservation VERIFIED";
llvm_verify m "count_n" [count_inv] false count_n_spec z3;
print "  count_n VERIFIED";
print "";

// ============================================================
// Example 3: Simple accumulator with 4 variables
// 4 variables: a, b, n, i (all passed to breakpoint)
// ============================================================

print "--- Example 3: accumulate (4 variables) ---";

let acc_spec = do {
    a <- llvm_fresh_var "a" (llvm_int 64);
    n <- llvm_fresh_var "n" (llvm_int 64);

    llvm_execute_func [llvm_term a, llvm_term n];

    llvm_return (llvm_term {{ accumulate a n }});
};

// Invariant: acc_rest computes result from current state
let acc_inv_spec = do {
    (pa, a) <- ptr_to_fresh "a" (llvm_int 64);
    (pb, b) <- ptr_to_fresh "b" (llvm_int 64);
    (pn, n) <- ptr_to_fresh "n" (llvm_int 64);
    (pi, i) <- ptr_to_fresh "i" (llvm_int 64);

    llvm_precond {{ i <= n }};

    llvm_execute_func [pa, pb, pn, pi];

    llvm_return (llvm_term {{ acc_rest a b n i }});
};

acc_inv <- llvm_unsafe_assume_spec m "__breakpoint__acc_inv#accumulate" acc_inv_spec;
print "  Invariant assumed";
llvm_verify m "__breakpoint__acc_inv#accumulate" [acc_inv] false acc_inv_spec z3;
print "  Invariant preservation VERIFIED";
llvm_verify m "accumulate" [acc_inv] false acc_spec z3;
print "  accumulate VERIFIED";
print "";

print "=== All examples verified ===";
print "";
print "KEY INSIGHT: Breakpoints work when ALL live variables are passed.";
print "See mini_sha.saw for compositional verification with uninterpreted functions.";
